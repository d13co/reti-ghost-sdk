#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 8 1 2
    bytecblock 0x151f7c75 0x151f7c750000000000000000000000000000000000000000000000000000
    // smart_contracts/reti_reader/contract.algo.ts:34
    // export class RetiReader extends Contract {
    txn NumAppArgs
    bz main_adminOnly@16
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    pushbytess 0xd7bf8445 0x84c4425a 0x24e00c80 0xbb882927 0xa62f1132 0xc2c98a6b 0x3d3b8b4a 0xbb460bee 0x0cc29dd8 // method "getMbrAmountsAndProtocolConstraints(uint64)((uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64))", method "getValidatorConfig(uint64,uint64[])(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)", method "getValidatorStates(uint64,uint64[])(uint16,uint64,uint64,uint64)", method "getPools(uint64,uint64[])(uint64,(uint64,uint16,uint64))", method "getNodePoolAssignments(uint64,uint64[])((uint64[3])[8])", method "getValidators(uint64,uint64[])((uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64),(uint16,uint64,uint64,uint64),(uint64,uint16,uint64)[],((uint64[3])[8]))", method "getBlockTimestamps(uint64)uint64", method "getAlgodVersion(uint64[])string", method "getAssets(uint64[])(uint64,address,uint64,uint8,string,string)"
    txna ApplicationArgs 0
    match getMbrAmountsAndProtocolConstraints getValidatorConfig getValidatorStates getPools getNodePoolAssignments getValidators getBlockTimestamps getAlgodVersion getAssets
    err

main_adminOnly@16:
    // smart_contracts/reti_reader/contract.algo.ts:35
    // @baremethod({ allowActions: ["UpdateApplication", "DeleteApplication"] })
    intc_2 // 1
    txn OnCompletion
    shl
    pushint 48 // 48
    &
    txn ApplicationID
    &&
    assert // OnCompletion must be one of UpdateApplication, DeleteApplication && can only call when not creating
    // smart_contracts/reti_reader/contract.algo.ts:37
    // assert(Txn.sender === Global.creatorAddress);
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/reti_reader/contract.algo.ts:35
    // @baremethod({ allowActions: ["UpdateApplication", "DeleteApplication"] })
    return


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getMbrAmountsAndProtocolConstraints[routing]() -> void:
getMbrAmountsAndProtocolConstraints:
    // smart_contracts/reti_reader/contract.algo.ts:40
    // @abimethod({ readonly: true, onCreate: "allow" })
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/reti_reader/contract.algo.ts:43-45
    // const mbrAmounts = reti.call.getMbrAmounts({
    //   appId: registryAppId,
    // }).returnValue;
    itxn_begin
    pushbytes 0x8a87142d // method "getMbrAmounts()(uint64,uint64,uint64,uint64)"
    itxn_field ApplicationArgs
    intc_0 // 0
    itxn_field OnCompletion
    dup
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for MbrAmounts
    // smart_contracts/reti_reader/contract.algo.ts:47-49
    // const constraints = reti.call.getProtocolConstraints({
    //   appId: registryAppId,
    // }).returnValue;
    itxn_begin
    pushbytes 0xd1366cc3 // method "getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)"
    itxn_field ApplicationArgs
    intc_0 // 0
    itxn_field OnCompletion
    swap
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    pushint 88 // 88
    ==
    assert // invalid number of bytes for Constraints
    // smart_contracts/reti_reader/contract.algo.ts:51
    // log(encodeArc4({ mbrAmounts, constraints }));
    concat
    dup
    log
    // smart_contracts/reti_reader/contract.algo.ts:40
    // @abimethod({ readonly: true, onCreate: "allow" })
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getValidatorConfig[routing]() -> void:
getValidatorConfig:
    // smart_contracts/reti_reader/contract.algo.ts:59
    // @abimethod({ readonly: true, onCreate: "allow" })
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_1 // 8
    *
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<uint64>
    intc_0 // 0

getValidatorConfig_for_header@2:
    // smart_contracts/reti_reader/contract.algo.ts:61
    // for (const validatorId of validatorIds) {
    dup
    dig 2
    <
    bz getValidatorConfig_after_for@5
    dig 2
    extract 2 0
    dig 1
    dup
    cover 2
    intc_1 // 8
    *
    extract_uint64
    // smart_contracts/reti_reader/contract.algo.ts:62
    // log(encodeArc4(this.getRemoteValidatorConfig(registryAppId, validatorId)));
    dig 5
    swap
    callsub getRemoteValidatorConfig
    log
    intc_2 // 1
    +
    bury 1
    b getValidatorConfig_for_header@2

getValidatorConfig_after_for@5:
    // smart_contracts/reti_reader/contract.algo.ts:59
    // @abimethod({ readonly: true, onCreate: "allow" })
    pushbytes base32(CUPXY5IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)
    log
    intc_2 // 1
    return


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getValidatorStates[routing]() -> void:
getValidatorStates:
    // smart_contracts/reti_reader/contract.algo.ts:97
    // @abimethod({ readonly: true, onCreate: "allow" })
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_1 // 8
    *
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<uint64>
    intc_0 // 0

getValidatorStates_for_header@2:
    // smart_contracts/reti_reader/contract.algo.ts:99
    // for (const validatorId of validatorIds) {
    dup
    dig 2
    <
    bz getValidatorStates_after_for@5
    dig 2
    extract 2 0
    dig 1
    dup
    cover 2
    intc_1 // 8
    *
    extract_uint64
    // smart_contracts/reti_reader/contract.algo.ts:100
    // log(encodeArc4(this.getRemoteValidatorState(registryAppId, validatorId)));
    dig 5
    swap
    callsub getRemoteValidatorState
    log
    intc_2 // 1
    +
    bury 1
    b getValidatorStates_for_header@2

getValidatorStates_after_for@5:
    // smart_contracts/reti_reader/contract.algo.ts:97
    // @abimethod({ readonly: true, onCreate: "allow" })
    bytec_1 // 0x151f7c750000000000000000000000000000000000000000000000000000
    log
    intc_2 // 1
    return


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getPools[routing]() -> void:
getPools:
    intc_0 // 0
    pushbytes ""
    dupn 2
    // smart_contracts/reti_reader/contract.algo.ts:121
    // @abimethod({ readonly: true, onCreate: "allow" })
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_1 // 8
    *
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<uint64>
    intc_0 // 0

getPools_for_header@2:
    // smart_contracts/reti_reader/contract.algo.ts:124
    // for (const validatorId of validatorIds) {
    dup
    dig 2
    <
    bz getPools_after_for@9
    dig 2
    extract 2 0
    dig 1
    intc_1 // 8
    *
    extract_uint64
    dup
    bury 6
    // smart_contracts/reti_reader/contract.algo.ts:125
    // const poolInfoArr = this.getRemotePoolInfo(registryAppId, validatorId);
    dig 4
    swap
    callsub getRemotePoolInfo
    dup
    bury 9
    // smart_contracts/reti_reader/contract.algo.ts:126
    // for (const poolInfo of clone(poolInfoArr)) {
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    bury 7
    intc_0 // 0
    bury 6

getPools_for_header@4:
    // smart_contracts/reti_reader/contract.algo.ts:126
    // for (const poolInfo of clone(poolInfoArr)) {
    dig 5
    dig 7
    <
    bz getPools_after_for@7
    dig 7
    extract 2 0
    dig 6
    dup
    cover 2
    pushint 18 // 18
    *
    pushint 18 // 18
    extract3 // on error: index access is out of bounds
    // smart_contracts/reti_reader/contract.algo.ts:127
    // log(encodeArc4({ validatorId, poolInfo }));
    dig 6
    itob
    swap
    concat
    log
    intc_2 // 1
    +
    bury 6
    b getPools_for_header@4

getPools_after_for@7:
    dup
    intc_2 // 1
    +
    bury 1
    b getPools_for_header@2

getPools_after_for@9:
    // smart_contracts/reti_reader/contract.algo.ts:121
    // @abimethod({ readonly: true, onCreate: "allow" })
    bytec_1 // 0x151f7c750000000000000000000000000000000000000000000000000000
    log
    intc_2 // 1
    return


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getNodePoolAssignments[routing]() -> void:
getNodePoolAssignments:
    // smart_contracts/reti_reader/contract.algo.ts:152
    // @abimethod({ readonly: true, onCreate: "allow" })
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_1 // 8
    *
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<uint64>
    intc_0 // 0

getNodePoolAssignments_for_header@2:
    // smart_contracts/reti_reader/contract.algo.ts:154
    // for (const validatorId of validatorIds) {
    dup
    dig 2
    <
    bz getNodePoolAssignments_after_for@5
    dig 2
    extract 2 0
    dig 1
    dup
    cover 2
    intc_1 // 8
    *
    extract_uint64
    // smart_contracts/reti_reader/contract.algo.ts:155
    // log(encodeArc4(this.getRemoteNodePoolAssignments(registryAppId, validatorId)));
    dig 5
    swap
    callsub getRemoteNodePoolAssignments
    log
    intc_2 // 1
    +
    bury 1
    b getNodePoolAssignments_for_header@2

getNodePoolAssignments_after_for@5:
    // smart_contracts/reti_reader/contract.algo.ts:152
    // @abimethod({ readonly: true, onCreate: "allow" })
    pushbytes 0x151f7c75000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
    log
    intc_2 // 1
    return


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getValidators[routing]() -> void:
getValidators:
    // smart_contracts/reti_reader/contract.algo.ts:174
    // @abimethod({ readonly: true, onCreate: "allow" })
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_1 // 8
    *
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<uint64>
    intc_0 // 0

getValidators_for_header@2:
    // smart_contracts/reti_reader/contract.algo.ts:176
    // for (const validatorId of validatorIds) {
    dup
    dig 2
    <
    bz getValidators_after_for@5
    dig 2
    extract 2 0
    dig 1
    dup
    cover 2
    intc_1 // 8
    *
    extract_uint64
    // smart_contracts/reti_reader/contract.algo.ts:179
    // const config = this.getRemoteValidatorConfig(registryAppId, validatorId);
    dig 5
    dup
    cover 2
    dig 1
    callsub getRemoteValidatorConfig
    // smart_contracts/reti_reader/contract.algo.ts:180
    // const state = this.getRemoteValidatorState(registryAppId, validatorId);
    dig 2
    dig 2
    callsub getRemoteValidatorState
    // smart_contracts/reti_reader/contract.algo.ts:181
    // const poolInfo = this.getRemotePoolInfo(registryAppId, validatorId);
    dig 3
    dig 3
    callsub getRemotePoolInfo
    // smart_contracts/reti_reader/contract.algo.ts:182
    // const nodeAssignment = this.getRemoteNodePoolAssignments(registryAppId, validatorId);
    uncover 4
    uncover 4
    callsub getRemoteNodePoolAssignments
    // smart_contracts/reti_reader/contract.algo.ts:184-189
    // const allPoolInfo: Validator = {
    //   config: clone(config),
    //   state: clone(state),
    //   poolInfo: clone(poolInfo),
    //   nodeAssignment: clone(nodeAssignment),
    // };
    uncover 3
    uncover 3
    concat
    pushbytes 0x01ce
    concat
    swap
    concat
    swap
    concat
    // smart_contracts/reti_reader/contract.algo.ts:190
    // log(encodeArc4(allPoolInfo));
    log
    intc_2 // 1
    +
    bury 1
    b getValidators_for_header@2

getValidators_after_for@5:
    // smart_contracts/reti_reader/contract.algo.ts:174
    // @abimethod({ readonly: true, onCreate: "allow" })
    pushbytes base32(CUPXY5IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADTQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)
    log
    intc_2 // 1
    return


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getBlockTimestamps[routing]() -> void:
getBlockTimestamps:
    // smart_contracts/reti_reader/contract.algo.ts:201
    // @abimethod({ readonly: true, onCreate: "allow" })
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/reti_reader/contract.algo.ts:203
    // for (let round: uint64 = Txn.lastValid - num - 1; round < Txn.firstValid - 1; round++) {
    txn LastValid
    swap
    -
    intc_2 // 1
    -

getBlockTimestamps_while_top@2:
    // smart_contracts/reti_reader/contract.algo.ts:203
    // for (let round: uint64 = Txn.lastValid - num - 1; round < Txn.firstValid - 1; round++) {
    txn FirstValid
    intc_2 // 1
    -
    dig 1
    >
    bz getBlockTimestamps_after_while@4
    // smart_contracts/reti_reader/contract.algo.ts:204
    // log(op.Block.blkTimestamp(round));
    dupn 2
    block BlkTimestamp
    itob
    log
    // smart_contracts/reti_reader/contract.algo.ts:203
    // for (let round: uint64 = Txn.lastValid - num - 1; round < Txn.firstValid - 1; round++) {
    intc_2 // 1
    +
    bury 1
    b getBlockTimestamps_while_top@2

getBlockTimestamps_after_while@4:
    // smart_contracts/reti_reader/contract.algo.ts:201
    // @abimethod({ readonly: true, onCreate: "allow" })
    pushbytes 0x151f7c750000000000000000
    log
    intc_2 // 1
    return


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getAlgodVersion[routing]() -> void:
getAlgodVersion:
    intc_0 // 0
    // smart_contracts/reti_reader/contract.algo.ts:209
    // @abimethod({ readonly: true, onCreate: "allow" })
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_1 // 8
    *
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<uint64>
    intc_0 // 0

getAlgodVersion_for_header@2:
    // smart_contracts/reti_reader/contract.algo.ts:211
    // for (const poolAppId of poolAppIds) {
    dup
    dig 2
    <
    bz getAlgodVersion_after_for@8
    dig 2
    extract 2 0
    dig 1
    intc_1 // 8
    *
    extract_uint64
    // smart_contracts/reti_reader/contract.algo.ts:212
    // const [algodVer, exists] = op.AppGlobal.getExBytes(poolAppId, Bytes`algodVer`);
    pushbytes "algodVer"
    app_global_get_ex
    swap
    bury 5
    // smart_contracts/reti_reader/contract.algo.ts:213
    // if (exists) {
    bz getAlgodVersion_else_body@5
    // smart_contracts/reti_reader/contract.algo.ts:214
    // log(encodeArc4(algodVer));
    dig 3
    dup
    len
    itob
    extract 6 2
    swap
    concat
    log

getAlgodVersion_after_if_else@6:
    dup
    intc_2 // 1
    +
    bury 1
    b getAlgodVersion_for_header@2

getAlgodVersion_else_body@5:
    // smart_contracts/reti_reader/contract.algo.ts:216
    // log(encodeArc4(""));
    pushbytes 0x0000
    log
    b getAlgodVersion_after_if_else@6

getAlgodVersion_after_for@8:
    // smart_contracts/reti_reader/contract.algo.ts:209
    // @abimethod({ readonly: true, onCreate: "allow" })
    pushbytes 0x151f7c750000
    log
    intc_2 // 1
    return


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getAssets[routing]() -> void:
getAssets:
    intc_0 // 0
    // smart_contracts/reti_reader/contract.algo.ts:222
    // @abimethod({ readonly: true, onCreate: "allow" })
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_1 // 8
    *
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<asset>
    intc_0 // 0

getAssets_for_header@2:
    // smart_contracts/reti_reader/contract.algo.ts:224
    // for (const asset of assetIds) {
    dup
    dig 2
    <
    bz getAssets_after_for@8
    dig 2
    extract 2 0
    dig 1
    intc_1 // 8
    *
    extract_uint64
    dup
    // smart_contracts/reti_reader/contract.algo.ts:225
    // const [creator, exists] = op.AssetParams.assetCreator(asset.id);
    asset_params_get AssetCreator
    swap
    bury 6
    // smart_contracts/reti_reader/contract.algo.ts:226
    // if (!exists) {
    bnz getAssets_else_body@5
    // smart_contracts/reti_reader/contract.algo.ts:227
    // log(encodeArc4(this.getEmptyAssetInfo(asset.id)));
    callsub getEmptyAssetInfo
    log

getAssets_after_if_else@6:
    dup
    intc_2 // 1
    +
    bury 1
    b getAssets_for_header@2

getAssets_else_body@5:
    // smart_contracts/reti_reader/contract.algo.ts:232
    // total: asset.total,
    dup
    asset_params_get AssetTotal
    assert // asset exists
    // smart_contracts/reti_reader/contract.algo.ts:233
    // decimals: new Uint8(asset.decimals),
    dig 1
    asset_params_get AssetDecimals
    assert // asset exists
    itob
    dup
    bitlen
    intc_1 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/reti_reader/contract.algo.ts:234
    // unitName: asset.unitName.toString(),
    dig 2
    asset_params_get AssetUnitName
    assert // asset exists
    // smart_contracts/reti_reader/contract.algo.ts:235
    // name: asset.name.toString(),
    dig 3
    asset_params_get AssetName
    assert // asset exists
    // smart_contracts/reti_reader/contract.algo.ts:229-236
    // const assetInfo: AssetInfo = {
    //   assetId: asset.id,
    //   creator: creator,
    //   total: asset.total,
    //   decimals: new Uint8(asset.decimals),
    //   unitName: asset.unitName.toString(),
    //   name: asset.name.toString(),
    // };
    uncover 4
    itob
    dig 8
    concat
    uncover 4
    itob
    concat
    uncover 3
    concat
    dig 2
    len
    itob
    extract 6 2
    uncover 3
    concat
    swap
    pushbytes 0x0035
    concat
    dig 1
    len
    pushint 53 // 53
    +
    dig 3
    len
    itob
    extract 6 2
    uncover 4
    concat
    swap
    itob
    extract 6 2
    uncover 2
    swap
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/reti_reader/contract.algo.ts:237
    // log(encodeArc4(assetInfo));
    log
    b getAssets_after_if_else@6

getAssets_after_for@8:
    // smart_contracts/reti_reader/contract.algo.ts:240
    // return this.getEmptyAssetInfo(0);
    intc_0 // 0
    callsub getEmptyAssetInfo
    // smart_contracts/reti_reader/contract.algo.ts:222
    // @abimethod({ readonly: true, onCreate: "allow" })
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getRemoteValidatorConfig(registryAppId: uint64, validatorId: uint64) -> bytes:
getRemoteValidatorConfig:
    // smart_contracts/reti_reader/contract.algo.ts:67
    // private getRemoteValidatorConfig(registryAppId: uint64, validatorId: uint64): ValidatorConfig {
    proto 2 1
    // smart_contracts/reti_reader/contract.algo.ts:68-71
    // return compileArc4(Reti).call.getValidatorConfig({
    //   appId: registryAppId,
    //   args: [validatorId],
    // }).returnValue;
    itxn_begin
    // smart_contracts/reti_reader/contract.algo.ts:70
    // args: [validatorId],
    frame_dig -1
    itob
    // smart_contracts/reti_reader/contract.algo.ts:68-71
    // return compileArc4(Reti).call.getValidatorConfig({
    //   appId: registryAppId,
    //   args: [validatorId],
    // }).returnValue;
    pushbytes 0x75aff61d // method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    intc_0 // 0
    itxn_field OnCompletion
    frame_dig -2
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    pushint 242 // 242
    ==
    assert // invalid number of bytes for ValidatorConfig
    retsub


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getRemoteValidatorState(registryAppId: uint64, validatorId: uint64) -> bytes:
getRemoteValidatorState:
    // smart_contracts/reti_reader/contract.algo.ts:105
    // private getRemoteValidatorState(registryAppId: uint64, validatorId: uint64): ValidatorCurState {
    proto 2 1
    // smart_contracts/reti_reader/contract.algo.ts:106-109
    // return compileArc4(Reti).call.getValidatorState({
    //   appId: registryAppId,
    //   args: [validatorId],
    // }).returnValue;
    itxn_begin
    // smart_contracts/reti_reader/contract.algo.ts:108
    // args: [validatorId],
    frame_dig -1
    itob
    // smart_contracts/reti_reader/contract.algo.ts:106-109
    // return compileArc4(Reti).call.getValidatorState({
    //   appId: registryAppId,
    //   args: [validatorId],
    // }).returnValue;
    pushbytes 0x1f2f0109 // method "getValidatorState(uint64)(uint16,uint64,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    intc_0 // 0
    itxn_field OnCompletion
    frame_dig -2
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    pushint 26 // 26
    ==
    assert // invalid number of bytes for ValidatorCurState
    retsub


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getRemotePoolInfo(registryAppId: uint64, validatorId: uint64) -> bytes:
getRemotePoolInfo:
    // smart_contracts/reti_reader/contract.algo.ts:134
    // private getRemotePoolInfo(registryAppId: uint64, validatorId: uint64): PoolInfo[] {
    proto 2 1
    // smart_contracts/reti_reader/contract.algo.ts:135-138
    // return compileArc4(Reti).call.getPools({
    //   appId: registryAppId,
    //   args: [validatorId],
    // }).returnValue;
    itxn_begin
    // smart_contracts/reti_reader/contract.algo.ts:137
    // args: [validatorId],
    frame_dig -1
    itob
    // smart_contracts/reti_reader/contract.algo.ts:135-138
    // return compileArc4(Reti).call.getPools({
    //   appId: registryAppId,
    //   args: [validatorId],
    // }).returnValue;
    pushbytes 0x910e94ac // method "getPools(uint64)(uint64,uint16,uint64)[]"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    intc_0 // 0
    itxn_field OnCompletion
    frame_dig -2
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 18 // 18
    *
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<PoolInfo>
    retsub


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getRemoteNodePoolAssignments(registryAppId: uint64, validatorId: uint64) -> bytes:
getRemoteNodePoolAssignments:
    // smart_contracts/reti_reader/contract.algo.ts:160
    // private getRemoteNodePoolAssignments(registryAppId: uint64, validatorId: uint64): NodePoolAssignmentConfig {
    proto 2 1
    // smart_contracts/reti_reader/contract.algo.ts:161-164
    // return compileArc4(Reti).call.getNodePoolAssignments({
    //   appId: registryAppId,
    //   args: [validatorId],
    // }).returnValue;
    itxn_begin
    // smart_contracts/reti_reader/contract.algo.ts:163
    // args: [validatorId],
    frame_dig -1
    itob
    // smart_contracts/reti_reader/contract.algo.ts:161-164
    // return compileArc4(Reti).call.getNodePoolAssignments({
    //   appId: registryAppId,
    //   args: [validatorId],
    // }).returnValue;
    pushbytes 0x7bbb6c8d // method "getNodePoolAssignments(uint64)((uint64[3])[8])"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    intc_0 // 0
    itxn_field OnCompletion
    frame_dig -2
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    pushint 192 // 192
    ==
    assert // invalid number of bytes for NodePoolAssignmentConfig
    retsub


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getEmptyAssetInfo(assetId: uint64) -> bytes:
getEmptyAssetInfo:
    // smart_contracts/reti_reader/contract.algo.ts:243
    // private getEmptyAssetInfo(assetId: uint64): AssetInfo {
    proto 1 1
    // smart_contracts/reti_reader/contract.algo.ts:246
    // creator: Global.zeroAddress,
    global ZeroAddress
    // smart_contracts/reti_reader/contract.algo.ts:244-251
    // return {
    //   assetId: assetId,
    //   creator: Global.zeroAddress,
    //   total: 0,
    //   decimals: new Uint8(0),
    //   unitName: "",
    //   name: "",
    // };
    frame_dig -1
    itob
    swap
    concat
    // smart_contracts/reti_reader/contract.algo.ts:247
    // total: 0,
    intc_0 // 0
    // smart_contracts/reti_reader/contract.algo.ts:244-251
    // return {
    //   assetId: assetId,
    //   creator: Global.zeroAddress,
    //   total: 0,
    //   decimals: new Uint8(0),
    //   unitName: "",
    //   name: "",
    // };
    itob
    concat
    pushbytes 0x000035003700000000
    concat
    retsub
